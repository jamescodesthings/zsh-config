#!/usr/bin/env zsh

# Example of using zparseopts
# From https://xpmo.gitlab.io/post/using-zparseopts/

parseex/usage() {
  echo "Usage: $1 [options]"
  echo "Options:"
  echo "-a/--arg [arg]: stores in \$arg"
  echo "-f/--flag: stores in \$flag"
  echo "--F/--foo: stores in \$foobar"
  echo "--B/--bar: stores in \$foobar (overrides bar)"
  # Arguments may be mixed in with flags
  # The flag -a/--arg takes an argument, store in $arg.
  # Store the flag -f/--flag in $flag.
  # The two flags -F/--foo and -B/--bar override each other, store in $foobar.
  # -- denotes end-of-options.
  # If an unknown flag is provided before --, error out.
  # After parsing, "$@" should be removed of all parsed flags and the -- end-of-options indicator.

}

parseex() {
  local DEPS=(
    is
    clr_cyan
    clr_white
  )

  if ! deps $DEPS; then
    return
  fi
  # After Zsh 5.8
  zmodload zsh/zutil
  zparseopts -F -E -D -A opts -- \
             -include: \
             -exclude-file-ext: \
             -show-only \
             # &>/dev/null

  if is not equal "$?" "0"; then
    parseex/usage $0
    return 1
  fi

  echo "opts good: $?"
  for key val in "${(@kv)opts}"; do
    echo "$key -> $val"
  done
  echo "Remaining: $@"
}

parseex "$@"
